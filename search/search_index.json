{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dicas, artigos e projetos... links no menu Social Media LinkedIN Github Youtube Email","title":"Home"},{"location":"#social-media","text":"","title":"Social Media"},{"location":"#linkedin","text":"","title":" LinkedIN"},{"location":"#github","text":"","title":" Github"},{"location":"#youtube","text":"","title":" Youtube"},{"location":"#email","text":"","title":" Email"},{"location":"docker/","text":"Docker Under development","title":"Docker"},{"location":"docker/#docker","text":"Under development","title":"Docker"},{"location":"kubernetes/","text":"Kubernetes Subindo uma aplica\u00e7\u00e3o PHP no Kubernetes com Gitlab-CI Nos \u00faltimos meses tenho trabalhado intensamente com a implanta\u00e7\u00e3o de Kubernetes na Tray. Apesar de ainda estarmos em est\u00e1gio de avalia\u00e7\u00f5es e testes e sabendo que ainda h\u00e1 muito o que aprender gostaria de compartilhar um pouco do acabei conhecendo nestes meses de estudo. Nesta s\u00e9rie de artigos pretendo demonstrar desde a constru\u00e7\u00e3o da imagem do container base da aplica\u00e7\u00e3o at\u00e9 o seu deploy via pipeline. Parte 1 - Construindo a imagem da aplica\u00e7\u00e3o Parte 2 - Criando os arquivos de manifesto da Aplica\u00e7\u00e3o (Kubernetes) Parte 3 - Criando uma pipeline para o deploy com Gitlab-CI","title":"Kubernetes"},{"location":"kubernetes/#kubernetes","text":"","title":"Kubernetes"},{"location":"kubernetes/#subindo-uma-aplicacao-php-no-kubernetes-com-gitlab-ci","text":"Nos \u00faltimos meses tenho trabalhado intensamente com a implanta\u00e7\u00e3o de Kubernetes na Tray. Apesar de ainda estarmos em est\u00e1gio de avalia\u00e7\u00f5es e testes e sabendo que ainda h\u00e1 muito o que aprender gostaria de compartilhar um pouco do acabei conhecendo nestes meses de estudo. Nesta s\u00e9rie de artigos pretendo demonstrar desde a constru\u00e7\u00e3o da imagem do container base da aplica\u00e7\u00e3o at\u00e9 o seu deploy via pipeline.","title":"Subindo uma aplica\u00e7\u00e3o PHP no Kubernetes com Gitlab-CI"},{"location":"kubernetes/#parte-1-construindo-a-imagem-da-aplicacao","text":"","title":"Parte 1 - Construindo a imagem da aplica\u00e7\u00e3o"},{"location":"kubernetes/#parte-2-criando-os-arquivos-de-manifesto-da-aplicacao-kubernetes","text":"","title":"Parte 2 - Criando os arquivos de manifesto da Aplica\u00e7\u00e3o (Kubernetes)"},{"location":"kubernetes/#parte-3-criando-uma-pipeline-para-o-deploy-com-gitlab-ci","text":"","title":"Parte 3 - Criando uma pipeline para o deploy com Gitlab-CI"},{"location":"php-k8s-gitlab-parte1/","text":"Subindo uma aplica\u00e7\u00e3o PHP no Kubernetes com Gitlab-CI - Parte 1 - Construindo a imagem da aplica\u00e7\u00e3o Este \u00e9 o primeiro de 3 artigos que pretendo escrever e nele quero compartilhar um pouco sobre a constru\u00e7\u00e3o de imagens otimizadas utilizando o Builder Pattern. Parte 2 - Criando os arquivos de manifesto da Aplica\u00e7\u00e3o (Kubernetes) Parte 3 - Criando uma pipeline para o deploy com Gitlab-CI Por que PHP? O artigo poderia ser escrito utilizando qualquer outra tecnologia como Golang, Python, Java, Node, etc\u2026 A escolha pelo PHP se d\u00e1 por 2 motivos. O primeiro e mais \u00f3bvio \u00e9 porque \u00e9 a tecnologia que utilizo no dia-a-dia, no trabalho e tenho mais afinidade. O segundo motivo foi uma das raz\u00f5es que me levaram \u00e0 escrever o artigo, justamente a menor quantidade de artigos e exemplos utilizando PHP. Durante meus estudos notei que era mais f\u00e1cil encontrar informa\u00e7\u00f5es sobre outras tecnologias sendo \u201cdeployadas\u201d (se me permitem o neologismo) no Kubernetes do que PHP, por isso a escolha por ele. Antes de come\u00e7ar Se voc\u00ea est\u00e1 lendo este artigo eu presumo que j\u00e1 esteja familiarizado com a utiliza\u00e7\u00e3o de containers com Docker, caso este n\u00e3o seja o seu caso eu sugiro fortemente que voc\u00ea assista a s\u00e9rie \u201c Descomplicando Docker \u201d do canal LinuxTips. \u00c9 importante antes de seguir lendo o artigo que voc\u00ea se familiarize com o conceito de imagens do Docker. Se voc\u00ea j\u00e1 tem conhecimento sobre utiliza\u00e7\u00e3o de containers com Docker, abaixo eu vou demonstrar uma forma de construir imagens menores para sua aplica\u00e7\u00e3o utilizando uma boa pr\u00e1tica para cria\u00e7\u00e3o de containers chamada Builder Pattern. Para saber um pouco mais sobre a t\u00e9cnica, vale a pena assistir este v\u00eddeo do Sandeep Dinesh do Google. Ali\u00e1s, recomendo assistir a toda s\u00e9rie \u201c Kubernetes Best Practices \u201d apresentada por ele. Agora, sem mais delongas vamos ao que interessa O problema de utilizar uma imagem padr\u00e3o Primeiramente precisamos entender qual \u00e9 a necessidade de criar imagens otimizadas sendo que seria muito mais f\u00e1cil utilizar as imagens padr\u00e3o encontradas no Docker Hub. Qual \u00e9 o problema disso? Bem, vamos criar uma situa\u00e7\u00e3o hipot\u00e9tica onde voc\u00ea tem um cluster Kubernetes rodando sua principal aplica\u00e7\u00e3o. Seu software \u00e9 uma plataforma de com\u00e9rcio eletr\u00f4nico rodando milhares de lojas de diversos tamanhos, desde pequenas lojas com 40 a 50 produtos at\u00e9 grandes lojas com milhares de produtos e vendendo milh\u00f5es de reais por m\u00eas. Pensar no gerenciamento de escala manual de um ambiente como este j\u00e1 \u00e9 de arrepiar os cabelos, mas felizmente o Kubernetes nos oferece o autoscaling horizontal de pods e os Cloud Providers em suas solu\u00e7\u00f5es gerenciadas de K8s oferecem o autoscaling de worker nodes, permitindo que elasticidade e escalabilidade n\u00e3o sejam problemas. O ambiente naturalmente se estica e diminui automaticamente conforme a carga que recebe, mantendo sua plataforma est\u00e1vel e ao mesmo tempo economizando recursos em per\u00edodos de ociosidade. Tudo maravilhoso, cada vez que sobe a quantidade de requests a um n\u00edvel que a plataforma n\u00e3o vai aguentar o autoscaling sobe novos nodes que baixam a imagem da sua aplica\u00e7\u00e3o e provisionam novos pods para atender estas requisi\u00e7\u00f5es. E \u00e9 a\u00ed que mora o problema! Imagine que seu maior cliente, resolve fazer uma a\u00e7\u00e3o de marketing no intervalo do jogo da final da copa e anuncia um desconto de 50% justamente nos itens que ele mais vende. Ah.. ele esqueceu de te informar a respeito. O resultado ser\u00e1 uma avalanche de requisi\u00e7\u00f5es repentinamente chegando no seu cluster, logicamente que com o crescimento das requests o autoscaling provisionar\u00e1 novos nodes, talvez dezenas, talvez centenas, que ter\u00e3o cada um deles que fazer o download da imagem da sua app antes de provisionar os pods e come\u00e7ar a atender as requisi\u00e7\u00f5es, \u00e9 muito prov\u00e1vel que durante algum tempo (talvez segundos, talvez minutos) requests sejam perdidas e seu cliente deixar\u00e1 de vender. \u00c9 uma situa\u00e7\u00e3o que n\u00e3o o deixar\u00e1 muito contente, lembre-se \u00e9 seu maior cliente, que investiu pesado em marketing e teve preju\u00edzo ao n\u00e3o conseguir atender a toda demanda que sua a\u00e7\u00e3o de marketing conseguiu atrair. Utilizando imagens menores para sua app o tempo para subir um novo node ser\u00e1 muito reduzido, e se n\u00e3o conseguir evitar 100% situa\u00e7\u00f5es como a exemplificada acima, certamente vai minimizar muito o impacto. Diferen\u00e7a de tamanho entre as imagens oficiais Vamos primeiramente baixar a imagem oficial do PHP-FPM do Docker Hub: $ docker pull php:7.3-fpm Vamos ver o tamanho da imagem default (baseada no Debian) Podemos observar que a imagem padr\u00e3o, sem adi\u00e7\u00e3o de nenhuma extens\u00e3o do PHP possui 398MB de tamanho. A imagem default do PHP \u00e9 baseada no Debian, mas j\u00e1 \u00e9 bem sabido que utilizar a distro Alpine Linux como base traz uma enorme economia de espa\u00e7o na imagem e esta \u00e9 a forma mais simples de se reduzir o tamanho da sua app. Vamos ver qual \u00e9 o tamanho da imagem PHP-FPM oficial utilizando o Alpine: $ docker pull php:7.3-fpm-alpine Como podemos observar a imagem com Alpine tem apenas 74.6MB uma economia de 323.4MB se comparada \u00e0 imagem Debian. Mas quem trabalha com PHP sabe que para levar uma aplica\u00e7\u00e3o \u00e0 produ\u00e7\u00e3o ser\u00e1 necess\u00e1rio instalar diversas extens\u00f5es que o PHP possui, seja para conex\u00e3o com banco de dados, autentica\u00e7\u00e3o com LDAP, compacta\u00e7\u00e3o, manipula\u00e7\u00e3o de imagens etc\u2026 Para termos uma no\u00e7\u00e3o eu criei um Dockerfile utilizando a imagem base padr\u00e3o do PHP-FPM e adicionando algumas extens\u00f5es que s\u00e3o frequentemente usadas: mbstring zip intl gd imap xml mysqli json bcmath bz2 pdo_mysql ldap Al\u00e9m dessas extens\u00f5es deixei a imagem preparada com o composer j\u00e1 instalado para o gerenciamento de depend\u00eancias da aplica\u00e7\u00e3o. Vejamos o Dockerfile dessa imagem: FROM php:7.3-fpm RUN apt-get update && apt-get upgrade # PHP MBSTRING RUN docker-php-ext-install mbstring # PHP-ZIP RUN apt-get install zlib1g-dev libzip-dev -y RUN docker-php-ext-install zip # PHP-INTL RUN apt-get install icu-devtools libicu-dev RUN docker-php-ext-configure intl && docker-php-ext-install intl # PHP-GD RUN apt-get install libpng-dev -y RUN docker-php-ext-configure gd && docker-php-ext-install gd # PHP-IMAP RUN apt-get install libc-client-dev libkrb5-dev -y RUN docker-php-ext-configure imap --with-kerberos --with-imap-ssl && docker-php-ext-install imap # PHP-XML RUN apt-get install libxml2-dev RUN docker-php-ext-configure xml && docker-php-ext-install xml # PHP-MYSQLi RUN docker-php-ext-configure mysqli && docker-php-ext-install mysqli # PHP-JSON RUN docker-php-ext-configure json && docker-php-ext-install json # PHP-BCMATH RUN docker-php-ext-configure bcmath && docker-php-ext-install bcmath # PHP-BZ2 RUN apt-get install libbz2-dev -y RUN docker-php-ext-configure bz2 && docker-php-ext-install bz2 # PHP-PDO RUN docker-php-ext-configure pdo && docker-php-ext-install pdo RUN docker-php-ext-configure pdo_mysql && docker-php-ext-install pdo_mysql # PHP-LDAP RUN apt-get install libldap2-dev RUN docker-php-ext-configure ldap && docker-php-ext-install ldap # Instalando o composer RUN php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" && \\ php composer-setup.php && \\ php -r \"unlink('composer-setup.php');\" && \\ mv composer.phar /usr/local/bin/composer && \\ /usr/local/bin/composer global require hirak/prestissimo Para \u201cbuildar\u201d esse Dockerfile executamos: $ docker build -t php7.3-ext-debian . Vejamos com que tamanho essa imagem ficou agora: S\u00e3o 126MB \u00e0 mais na imagem oficial Debian ap\u00f3s a adi\u00e7\u00e3o das extens\u00f5es, qual ser\u00e1 o resultado dessas adi\u00e7\u00f5es na imagem alpine? O Dockerfile Alpine ficou assim: FROM php:7.3-fpm-alpine RUN apk add --update php libstdc++ # PHP MBSTRING RUN docker-php-ext-install mbstring # PHP-ZIP RUN apk add --update zlib-dev libzip-dev RUN docker-php-ext-install zip # PHP-INTL RUN apk add --update icu-dev php7-intl RUN docker-php-ext-configure intl && docker-php-ext-install intl # PHP-GD RUN apk add --update libgd libpng-dev RUN docker-php-ext-configure gd && docker-php-ext-install gd # PHP-IMAP RUN apk add --update imap-dev RUN docker-php-ext-configure imap && docker-php-ext-install imap # PHP-XML RUN apk add --no-cache -X http://dl-cdn.alpinelinux.org/alpine/edge/testing libxml++-dev RUN docker-php-ext-configure xml && docker-php-ext-install xml # PHP-MYSQLi RUN docker-php-ext-configure mysqli && docker-php-ext-install mysqli # PHP-JSON RUN docker-php-ext-configure json && docker-php-ext-install json # PHP-BCMATH RUN docker-php-ext-configure bcmath && docker-php-ext-install bcmath # PHP-BZ2 RUN docker-php-ext-configure bz2 && docker-php-ext-install bz2 # PHP-PDO RUN docker-php-ext-configure pdo && docker-php-ext-install pdo RUN docker-php-ext-configure pdo_mysql && docker-php-ext-install pdo_mysql # PHP-LDAP RUN apk add --update openldap-dev RUN docker-php-ext-configure ldap && docker-php-ext-install ldap # Instalando o composer RUN php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" && \\ php composer-setup.php && \\ php -r \"unlink('composer-setup.php');\" && \\ mv composer.phar /usr/local/bin/composer && \\ /usr/local/bin/composer global require hirak/prestissimo E o resultado: Com 304MB a imagem est\u00e1 muito maior que que a imagem original Alpine mas ainda 220MB menor que a imagem Debian com as extens\u00f5es e ainda consegue ser menor que a imagem Debian original. Mas \u00e9 poss\u00edvel fazer melhor, como disse no in\u00edcio do artigo, ao utilizarmos o Builder Pattern para a cria\u00e7\u00e3o das imagens podemos economizar ainda mais espa\u00e7o em disco. Builder Pattern Mas o que cargas d\u2019\u00e1gua vem a ser esse tal padr\u00e3o? Bem, ao realizarmos as instala\u00e7\u00f5es das extens\u00f5es (ou a compila\u00e7\u00e3o para o caso de linguagens compiladas) o sistema baixa diversas bibliotecas e depend\u00eancias que somente ser\u00e3o utilizadas durante a instala\u00e7\u00e3o, inflando a imagem com arquivos que ser\u00e3o desnecess\u00e1rios para o funcionamento da aplica\u00e7\u00e3o. O Docker oferece um recurso chamado de multi-stage build, que nos permite fazer toda a gera\u00e7\u00e3o de depend\u00eancias em uma imagem tempor\u00e1ria e em seguida copiar apenas os arquivos que interessam para a imagem final, tornando-a muito menor. Este \u00e9 o Builder Pattern . Mas como fazemos isso? Um Dokerfile normalmente possui uma instru\u00e7\u00e3o FROM que determina qual ser\u00e1 a imagem base utilizada seguida das outras instru\u00e7\u00f5es para constru\u00e7\u00e3o da imagem (COPY, RUN, CMD, etc). No caso do Builder Pattern utiliza-se um ou mais comandos FROM pra gerar as depend\u00eancias que posteriormente ser\u00e3o copiadas para a imagem final. Veja o exemplo: ############################################################################### # Imagem PHP-7.3 otimizada para uso no cluster # Multi-stage build (builder pattern) # Primeiro realiza o build das extens\u00f5es necess\u00e1rias FROM php:7.3-fpm-alpine AS extensions_source ENV EXT_DIR=/usr/src/php/ext RUN mkdir -p ${EXT_DIR} RUN apk add --update php libstdc++ # PHP MBSTRING RUN docker-php-ext-install mbstring # PHP-ZIP RUN apk add --update zlib-dev libzip-dev RUN docker-php-ext-install zip # PHP-INTL RUN apk add --update icu-dev php7-intl RUN docker-php-ext-configure intl && docker-php-ext-install intl # PHP-GD RUN apk add --update libgd libpng-dev RUN docker-php-ext-configure gd && docker-php-ext-install gd # PHP-IMAP RUN apk add --update imap-dev RUN docker-php-ext-configure imap && docker-php-ext-install imap # PHP-XML RUN apk add --no-cache -X http://dl-cdn.alpinelinux.org/alpine/edge/testing libxml++-dev RUN docker-php-ext-configure xml && docker-php-ext-install xml # PHP-MYSQLi RUN docker-php-ext-configure mysqli && docker-php-ext-install mysqli # PHP-JSON RUN docker-php-ext-configure json && docker-php-ext-install json # PHP-BCMATH RUN docker-php-ext-configure bcmath && docker-php-ext-install bcmath # PHP-BZ2 RUN docker-php-ext-configure bz2 && docker-php-ext-install bz2 # PHP-PDO RUN docker-php-ext-configure pdo && docker-php-ext-install pdo RUN docker-php-ext-configure pdo_mysql && docker-php-ext-install pdo_mysql # PHP-LDAP RUN apk add --update openldap-dev RUN docker-php-ext-configure ldap && docker-php-ext-install ldap # Est\u00e1gio 2 # Faz o build da imagem limpa, apenas copiando os arquivos necess\u00e1rios da imagem tempor\u00e1ria FROM php:7.3-fpm-alpine ENV EXT_DIR=/usr/local/lib/php/extensions/no-debug-non-zts-20180731/ ENV LIB_DIR=/usr/lib COPY --from=extensions_source \\ ${EXT_DIR}/mbstring.so \\ ${EXT_DIR}/zip.so \\ ${EXT_DIR}/intl.so \\ ${EXT_DIR}/gd.so \\ ${EXT_DIR}/imap.so \\ ${EXT_DIR}/xml.so \\ ${EXT_DIR}/mysqli.so \\ ${EXT_DIR}/json.so \\ ${EXT_DIR}/bcmath.so \\ ${EXT_DIR}/bz2.so \\ ${EXT_DIR}/pdo.so \\ ${EXT_DIR}/pdo_mysql.so \\ ${EXT_DIR}/ldap.so ${EXT_DIR}/ RUN ln -s ${LIB_DIR}/libzip.so ${LIB_DIR}/libzip.so.5 \\ && ln -s ${LIB_DIR}/libcrypto.so.1.1 ${LIB_DIR}/libcrypto.so \\ && ln -s ${LIB_DIR}/libssl.so.1.1 ${LIB_DIR}/libssl.so \\ && ln -s ${LIB_DIR}/libbz2.so ${LIB_DIR}/libbz2.so.1 \\ && ln -s ${LIB_DIR}/libicuio.so ${LIB_DIR}/libicuio.so.64 \\ && ln -s ${LIB_DIR}/libicui18n.so ${LIB_DIR}/libicui18n.so.64 \\ && ln -s ${LIB_DIR}/libicuuc.so ${LIB_DIR}/libicuuc.so.64 \\ && ln -s ${LIB_DIR}/libicudata.so ${LIB_DIR}/libicudata.so.64 \\ && ln -s ${LIB_DIR}/libldap.so ${LIB_DIR}/libldap-2.4.so.2 \\ && ln -s ${LIB_DIR}/liblber.so ${LIB_DIR}/liblber-2.4.so.2 \\ && ln -s ${LIB_DIR}/libsasl2.so ${LIB_DIR}/libsasl2.so.3 \\ && ln -s ${LIB_DIR}/libpng.so ${LIB_DIR}/libpng16.so \\ && ln -s ${LIB_DIR}/libpng.so ${LIB_DIR}/libpng16.so.16 \\ && ln -s ${LIB_DIR}/libc-client.so ${LIB_DIR}/libc-client.so.1 COPY --from=extensions_source \\ ${LIB_DIR}/libzip.so \\ ${LIB_DIR}/../../lib/libcrypto.so.1.1 \\ ${LIB_DIR}/../../lib/libssl.so.1.1 \\ ${LIB_DIR}/libstdc* \\ ${LIB_DIR}/libicudata.so \\ ${LIB_DIR}/libicui18n.so \\ ${LIB_DIR}/libicuio.so \\ ${LIB_DIR}/libicutest.so \\ ${LIB_DIR}/libicutu.so \\ ${LIB_DIR}/libicuuc.so \\ ${LIB_DIR}/libgcc_s.so.1 \\ ${LIB_DIR}/libpng.so \\ ${LIB_DIR}/libc-client.so \\ ${LIB_DIR}/libbz2.so \\ ${LIB_DIR}/libldap.so \\ ${LIB_DIR}/libldap_r-2.4.so.2 \\ ${LIB_DIR}/libldap_r.so \\ ${LIB_DIR}/liblber.so \\ ${LIB_DIR}/libsasl2.so ${LIB_DIR}/ RUN docker-php-ext-enable zip mbstring intl gd imap xml mysqli json bcmath \\ bz2 pdo pdo_mysql ldap # Refa\u00e7o a c\u00f3pia pois o comando docker-php-ext-enable faz purge de algumas libs COPY --from=extensions_source ${LIB_DIR}/libstdc* ${LIB_DIR}/libgcc_s.so.1 ${LIB_DIR}/ # Instalando o composer RUN php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" && \\ php composer-setup.php && \\ php -r \"unlink('composer-setup.php');\" && \\ mv composer.phar /usr/local/bin/composer && \\ /usr/local/bin/composer global require hirak/prestissimo # Limpando a imagem RUN rm -rf /var/cache/apk/* /tmp/* /usr/share/man /usr/local/lib/php/doc/* Note que primeiramente eu declaro um FROM e o nomeio utilizando o parametro AS e nesse est\u00e1gio s\u00e3o realizadas as instala\u00e7\u00f5es das extens\u00f5es necess\u00e1rias. Conclu\u00eddas as instala\u00e7\u00f5es, \u00e9 realizada a declara\u00e7\u00e3o de um novo FROM que far\u00e1 o build da imagem final. Neste est\u00e1gio utilizando o par\u00e2metro COPY --from=nome_do_est\u00e1gio \u00e9 poss\u00edvel referenciar o est\u00e1gio anterior e copiar apenas os arquivos que nos interessam. Adicionalmente, eu adiciono ao final do arquivo um comando para excluir arquivos de cache, tempor\u00e1rios e documenta\u00e7\u00e3o. Vejamos o resultado: A imagem gerada utilizando o Builder Pattern ficou com 156MB. S\u00e3o 148MB a menos que a imagem Alpine e 368MB de diferen\u00e7a para a imagem Debian. Uma redu\u00e7\u00e3o de 70% no tamanho original da imagem Debian com as extens\u00f5es. Conclus\u00e3o Vimos que: 1. Com o simples fato de optarmos pela distro Alpine Linux na hora de construir nossos containers podemos criar imagens muito mais enxutas; 2. Que com um pouquinho de trabalho, usando o Builder Pattern \u00e9 poss\u00edvel otimizar ainda mais estas imagens; 3. Quando estamos falando de imagens de container para o Kubernetes, tamanho \u00e9 sim importante . No pr\u00f3ximo post, entrarei no mundo do Kubernetes propriamente dito criando os arquivos de manifesto para o deploy de uma app PHP no K8s. At\u00e9 l\u00e1!","title":"Subindo uma aplica\u00e7\u00e3o PHP no Kubernetes com Gitlab-CI - Parte 1 - Construindo a imagem da aplica\u00e7\u00e3o"},{"location":"php-k8s-gitlab-parte1/#subindo-uma-aplicacao-php-no-kubernetes-com-gitlab-ci-parte-1-construindo-a-imagem-da-aplicacao","text":"Este \u00e9 o primeiro de 3 artigos que pretendo escrever e nele quero compartilhar um pouco sobre a constru\u00e7\u00e3o de imagens otimizadas utilizando o Builder Pattern. Parte 2 - Criando os arquivos de manifesto da Aplica\u00e7\u00e3o (Kubernetes) Parte 3 - Criando uma pipeline para o deploy com Gitlab-CI","title":"Subindo uma aplica\u00e7\u00e3o PHP no Kubernetes com Gitlab-CI - Parte 1 - Construindo a imagem da aplica\u00e7\u00e3o"},{"location":"php-k8s-gitlab-parte1/#por-que-php","text":"O artigo poderia ser escrito utilizando qualquer outra tecnologia como Golang, Python, Java, Node, etc\u2026 A escolha pelo PHP se d\u00e1 por 2 motivos. O primeiro e mais \u00f3bvio \u00e9 porque \u00e9 a tecnologia que utilizo no dia-a-dia, no trabalho e tenho mais afinidade. O segundo motivo foi uma das raz\u00f5es que me levaram \u00e0 escrever o artigo, justamente a menor quantidade de artigos e exemplos utilizando PHP. Durante meus estudos notei que era mais f\u00e1cil encontrar informa\u00e7\u00f5es sobre outras tecnologias sendo \u201cdeployadas\u201d (se me permitem o neologismo) no Kubernetes do que PHP, por isso a escolha por ele.","title":"Por que PHP?"},{"location":"php-k8s-gitlab-parte1/#antes-de-comecar","text":"Se voc\u00ea est\u00e1 lendo este artigo eu presumo que j\u00e1 esteja familiarizado com a utiliza\u00e7\u00e3o de containers com Docker, caso este n\u00e3o seja o seu caso eu sugiro fortemente que voc\u00ea assista a s\u00e9rie \u201c Descomplicando Docker \u201d do canal LinuxTips. \u00c9 importante antes de seguir lendo o artigo que voc\u00ea se familiarize com o conceito de imagens do Docker. Se voc\u00ea j\u00e1 tem conhecimento sobre utiliza\u00e7\u00e3o de containers com Docker, abaixo eu vou demonstrar uma forma de construir imagens menores para sua aplica\u00e7\u00e3o utilizando uma boa pr\u00e1tica para cria\u00e7\u00e3o de containers chamada Builder Pattern. Para saber um pouco mais sobre a t\u00e9cnica, vale a pena assistir este v\u00eddeo do Sandeep Dinesh do Google. Ali\u00e1s, recomendo assistir a toda s\u00e9rie \u201c Kubernetes Best Practices \u201d apresentada por ele. Agora, sem mais delongas vamos ao que interessa","title":"Antes de come\u00e7ar"},{"location":"php-k8s-gitlab-parte1/#o-problema-de-utilizar-uma-imagem-padrao","text":"Primeiramente precisamos entender qual \u00e9 a necessidade de criar imagens otimizadas sendo que seria muito mais f\u00e1cil utilizar as imagens padr\u00e3o encontradas no Docker Hub. Qual \u00e9 o problema disso? Bem, vamos criar uma situa\u00e7\u00e3o hipot\u00e9tica onde voc\u00ea tem um cluster Kubernetes rodando sua principal aplica\u00e7\u00e3o. Seu software \u00e9 uma plataforma de com\u00e9rcio eletr\u00f4nico rodando milhares de lojas de diversos tamanhos, desde pequenas lojas com 40 a 50 produtos at\u00e9 grandes lojas com milhares de produtos e vendendo milh\u00f5es de reais por m\u00eas. Pensar no gerenciamento de escala manual de um ambiente como este j\u00e1 \u00e9 de arrepiar os cabelos, mas felizmente o Kubernetes nos oferece o autoscaling horizontal de pods e os Cloud Providers em suas solu\u00e7\u00f5es gerenciadas de K8s oferecem o autoscaling de worker nodes, permitindo que elasticidade e escalabilidade n\u00e3o sejam problemas. O ambiente naturalmente se estica e diminui automaticamente conforme a carga que recebe, mantendo sua plataforma est\u00e1vel e ao mesmo tempo economizando recursos em per\u00edodos de ociosidade. Tudo maravilhoso, cada vez que sobe a quantidade de requests a um n\u00edvel que a plataforma n\u00e3o vai aguentar o autoscaling sobe novos nodes que baixam a imagem da sua aplica\u00e7\u00e3o e provisionam novos pods para atender estas requisi\u00e7\u00f5es. E \u00e9 a\u00ed que mora o problema! Imagine que seu maior cliente, resolve fazer uma a\u00e7\u00e3o de marketing no intervalo do jogo da final da copa e anuncia um desconto de 50% justamente nos itens que ele mais vende. Ah.. ele esqueceu de te informar a respeito. O resultado ser\u00e1 uma avalanche de requisi\u00e7\u00f5es repentinamente chegando no seu cluster, logicamente que com o crescimento das requests o autoscaling provisionar\u00e1 novos nodes, talvez dezenas, talvez centenas, que ter\u00e3o cada um deles que fazer o download da imagem da sua app antes de provisionar os pods e come\u00e7ar a atender as requisi\u00e7\u00f5es, \u00e9 muito prov\u00e1vel que durante algum tempo (talvez segundos, talvez minutos) requests sejam perdidas e seu cliente deixar\u00e1 de vender. \u00c9 uma situa\u00e7\u00e3o que n\u00e3o o deixar\u00e1 muito contente, lembre-se \u00e9 seu maior cliente, que investiu pesado em marketing e teve preju\u00edzo ao n\u00e3o conseguir atender a toda demanda que sua a\u00e7\u00e3o de marketing conseguiu atrair. Utilizando imagens menores para sua app o tempo para subir um novo node ser\u00e1 muito reduzido, e se n\u00e3o conseguir evitar 100% situa\u00e7\u00f5es como a exemplificada acima, certamente vai minimizar muito o impacto.","title":"O problema de utilizar uma imagem padr\u00e3o"},{"location":"php-k8s-gitlab-parte1/#diferenca-de-tamanho-entre-as-imagens-oficiais","text":"Vamos primeiramente baixar a imagem oficial do PHP-FPM do Docker Hub: $ docker pull php:7.3-fpm Vamos ver o tamanho da imagem default (baseada no Debian) Podemos observar que a imagem padr\u00e3o, sem adi\u00e7\u00e3o de nenhuma extens\u00e3o do PHP possui 398MB de tamanho. A imagem default do PHP \u00e9 baseada no Debian, mas j\u00e1 \u00e9 bem sabido que utilizar a distro Alpine Linux como base traz uma enorme economia de espa\u00e7o na imagem e esta \u00e9 a forma mais simples de se reduzir o tamanho da sua app. Vamos ver qual \u00e9 o tamanho da imagem PHP-FPM oficial utilizando o Alpine: $ docker pull php:7.3-fpm-alpine Como podemos observar a imagem com Alpine tem apenas 74.6MB uma economia de 323.4MB se comparada \u00e0 imagem Debian. Mas quem trabalha com PHP sabe que para levar uma aplica\u00e7\u00e3o \u00e0 produ\u00e7\u00e3o ser\u00e1 necess\u00e1rio instalar diversas extens\u00f5es que o PHP possui, seja para conex\u00e3o com banco de dados, autentica\u00e7\u00e3o com LDAP, compacta\u00e7\u00e3o, manipula\u00e7\u00e3o de imagens etc\u2026 Para termos uma no\u00e7\u00e3o eu criei um Dockerfile utilizando a imagem base padr\u00e3o do PHP-FPM e adicionando algumas extens\u00f5es que s\u00e3o frequentemente usadas: mbstring zip intl gd imap xml mysqli json bcmath bz2 pdo_mysql ldap Al\u00e9m dessas extens\u00f5es deixei a imagem preparada com o composer j\u00e1 instalado para o gerenciamento de depend\u00eancias da aplica\u00e7\u00e3o. Vejamos o Dockerfile dessa imagem: FROM php:7.3-fpm RUN apt-get update && apt-get upgrade # PHP MBSTRING RUN docker-php-ext-install mbstring # PHP-ZIP RUN apt-get install zlib1g-dev libzip-dev -y RUN docker-php-ext-install zip # PHP-INTL RUN apt-get install icu-devtools libicu-dev RUN docker-php-ext-configure intl && docker-php-ext-install intl # PHP-GD RUN apt-get install libpng-dev -y RUN docker-php-ext-configure gd && docker-php-ext-install gd # PHP-IMAP RUN apt-get install libc-client-dev libkrb5-dev -y RUN docker-php-ext-configure imap --with-kerberos --with-imap-ssl && docker-php-ext-install imap # PHP-XML RUN apt-get install libxml2-dev RUN docker-php-ext-configure xml && docker-php-ext-install xml # PHP-MYSQLi RUN docker-php-ext-configure mysqli && docker-php-ext-install mysqli # PHP-JSON RUN docker-php-ext-configure json && docker-php-ext-install json # PHP-BCMATH RUN docker-php-ext-configure bcmath && docker-php-ext-install bcmath # PHP-BZ2 RUN apt-get install libbz2-dev -y RUN docker-php-ext-configure bz2 && docker-php-ext-install bz2 # PHP-PDO RUN docker-php-ext-configure pdo && docker-php-ext-install pdo RUN docker-php-ext-configure pdo_mysql && docker-php-ext-install pdo_mysql # PHP-LDAP RUN apt-get install libldap2-dev RUN docker-php-ext-configure ldap && docker-php-ext-install ldap # Instalando o composer RUN php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" && \\ php composer-setup.php && \\ php -r \"unlink('composer-setup.php');\" && \\ mv composer.phar /usr/local/bin/composer && \\ /usr/local/bin/composer global require hirak/prestissimo Para \u201cbuildar\u201d esse Dockerfile executamos: $ docker build -t php7.3-ext-debian . Vejamos com que tamanho essa imagem ficou agora: S\u00e3o 126MB \u00e0 mais na imagem oficial Debian ap\u00f3s a adi\u00e7\u00e3o das extens\u00f5es, qual ser\u00e1 o resultado dessas adi\u00e7\u00f5es na imagem alpine? O Dockerfile Alpine ficou assim: FROM php:7.3-fpm-alpine RUN apk add --update php libstdc++ # PHP MBSTRING RUN docker-php-ext-install mbstring # PHP-ZIP RUN apk add --update zlib-dev libzip-dev RUN docker-php-ext-install zip # PHP-INTL RUN apk add --update icu-dev php7-intl RUN docker-php-ext-configure intl && docker-php-ext-install intl # PHP-GD RUN apk add --update libgd libpng-dev RUN docker-php-ext-configure gd && docker-php-ext-install gd # PHP-IMAP RUN apk add --update imap-dev RUN docker-php-ext-configure imap && docker-php-ext-install imap # PHP-XML RUN apk add --no-cache -X http://dl-cdn.alpinelinux.org/alpine/edge/testing libxml++-dev RUN docker-php-ext-configure xml && docker-php-ext-install xml # PHP-MYSQLi RUN docker-php-ext-configure mysqli && docker-php-ext-install mysqli # PHP-JSON RUN docker-php-ext-configure json && docker-php-ext-install json # PHP-BCMATH RUN docker-php-ext-configure bcmath && docker-php-ext-install bcmath # PHP-BZ2 RUN docker-php-ext-configure bz2 && docker-php-ext-install bz2 # PHP-PDO RUN docker-php-ext-configure pdo && docker-php-ext-install pdo RUN docker-php-ext-configure pdo_mysql && docker-php-ext-install pdo_mysql # PHP-LDAP RUN apk add --update openldap-dev RUN docker-php-ext-configure ldap && docker-php-ext-install ldap # Instalando o composer RUN php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" && \\ php composer-setup.php && \\ php -r \"unlink('composer-setup.php');\" && \\ mv composer.phar /usr/local/bin/composer && \\ /usr/local/bin/composer global require hirak/prestissimo E o resultado: Com 304MB a imagem est\u00e1 muito maior que que a imagem original Alpine mas ainda 220MB menor que a imagem Debian com as extens\u00f5es e ainda consegue ser menor que a imagem Debian original. Mas \u00e9 poss\u00edvel fazer melhor, como disse no in\u00edcio do artigo, ao utilizarmos o Builder Pattern para a cria\u00e7\u00e3o das imagens podemos economizar ainda mais espa\u00e7o em disco.","title":"Diferen\u00e7a de tamanho entre as imagens oficiais"},{"location":"php-k8s-gitlab-parte1/#builder-pattern","text":"Mas o que cargas d\u2019\u00e1gua vem a ser esse tal padr\u00e3o? Bem, ao realizarmos as instala\u00e7\u00f5es das extens\u00f5es (ou a compila\u00e7\u00e3o para o caso de linguagens compiladas) o sistema baixa diversas bibliotecas e depend\u00eancias que somente ser\u00e3o utilizadas durante a instala\u00e7\u00e3o, inflando a imagem com arquivos que ser\u00e3o desnecess\u00e1rios para o funcionamento da aplica\u00e7\u00e3o. O Docker oferece um recurso chamado de multi-stage build, que nos permite fazer toda a gera\u00e7\u00e3o de depend\u00eancias em uma imagem tempor\u00e1ria e em seguida copiar apenas os arquivos que interessam para a imagem final, tornando-a muito menor. Este \u00e9 o Builder Pattern . Mas como fazemos isso? Um Dokerfile normalmente possui uma instru\u00e7\u00e3o FROM que determina qual ser\u00e1 a imagem base utilizada seguida das outras instru\u00e7\u00f5es para constru\u00e7\u00e3o da imagem (COPY, RUN, CMD, etc). No caso do Builder Pattern utiliza-se um ou mais comandos FROM pra gerar as depend\u00eancias que posteriormente ser\u00e3o copiadas para a imagem final. Veja o exemplo: ############################################################################### # Imagem PHP-7.3 otimizada para uso no cluster # Multi-stage build (builder pattern) # Primeiro realiza o build das extens\u00f5es necess\u00e1rias FROM php:7.3-fpm-alpine AS extensions_source ENV EXT_DIR=/usr/src/php/ext RUN mkdir -p ${EXT_DIR} RUN apk add --update php libstdc++ # PHP MBSTRING RUN docker-php-ext-install mbstring # PHP-ZIP RUN apk add --update zlib-dev libzip-dev RUN docker-php-ext-install zip # PHP-INTL RUN apk add --update icu-dev php7-intl RUN docker-php-ext-configure intl && docker-php-ext-install intl # PHP-GD RUN apk add --update libgd libpng-dev RUN docker-php-ext-configure gd && docker-php-ext-install gd # PHP-IMAP RUN apk add --update imap-dev RUN docker-php-ext-configure imap && docker-php-ext-install imap # PHP-XML RUN apk add --no-cache -X http://dl-cdn.alpinelinux.org/alpine/edge/testing libxml++-dev RUN docker-php-ext-configure xml && docker-php-ext-install xml # PHP-MYSQLi RUN docker-php-ext-configure mysqli && docker-php-ext-install mysqli # PHP-JSON RUN docker-php-ext-configure json && docker-php-ext-install json # PHP-BCMATH RUN docker-php-ext-configure bcmath && docker-php-ext-install bcmath # PHP-BZ2 RUN docker-php-ext-configure bz2 && docker-php-ext-install bz2 # PHP-PDO RUN docker-php-ext-configure pdo && docker-php-ext-install pdo RUN docker-php-ext-configure pdo_mysql && docker-php-ext-install pdo_mysql # PHP-LDAP RUN apk add --update openldap-dev RUN docker-php-ext-configure ldap && docker-php-ext-install ldap # Est\u00e1gio 2 # Faz o build da imagem limpa, apenas copiando os arquivos necess\u00e1rios da imagem tempor\u00e1ria FROM php:7.3-fpm-alpine ENV EXT_DIR=/usr/local/lib/php/extensions/no-debug-non-zts-20180731/ ENV LIB_DIR=/usr/lib COPY --from=extensions_source \\ ${EXT_DIR}/mbstring.so \\ ${EXT_DIR}/zip.so \\ ${EXT_DIR}/intl.so \\ ${EXT_DIR}/gd.so \\ ${EXT_DIR}/imap.so \\ ${EXT_DIR}/xml.so \\ ${EXT_DIR}/mysqli.so \\ ${EXT_DIR}/json.so \\ ${EXT_DIR}/bcmath.so \\ ${EXT_DIR}/bz2.so \\ ${EXT_DIR}/pdo.so \\ ${EXT_DIR}/pdo_mysql.so \\ ${EXT_DIR}/ldap.so ${EXT_DIR}/ RUN ln -s ${LIB_DIR}/libzip.so ${LIB_DIR}/libzip.so.5 \\ && ln -s ${LIB_DIR}/libcrypto.so.1.1 ${LIB_DIR}/libcrypto.so \\ && ln -s ${LIB_DIR}/libssl.so.1.1 ${LIB_DIR}/libssl.so \\ && ln -s ${LIB_DIR}/libbz2.so ${LIB_DIR}/libbz2.so.1 \\ && ln -s ${LIB_DIR}/libicuio.so ${LIB_DIR}/libicuio.so.64 \\ && ln -s ${LIB_DIR}/libicui18n.so ${LIB_DIR}/libicui18n.so.64 \\ && ln -s ${LIB_DIR}/libicuuc.so ${LIB_DIR}/libicuuc.so.64 \\ && ln -s ${LIB_DIR}/libicudata.so ${LIB_DIR}/libicudata.so.64 \\ && ln -s ${LIB_DIR}/libldap.so ${LIB_DIR}/libldap-2.4.so.2 \\ && ln -s ${LIB_DIR}/liblber.so ${LIB_DIR}/liblber-2.4.so.2 \\ && ln -s ${LIB_DIR}/libsasl2.so ${LIB_DIR}/libsasl2.so.3 \\ && ln -s ${LIB_DIR}/libpng.so ${LIB_DIR}/libpng16.so \\ && ln -s ${LIB_DIR}/libpng.so ${LIB_DIR}/libpng16.so.16 \\ && ln -s ${LIB_DIR}/libc-client.so ${LIB_DIR}/libc-client.so.1 COPY --from=extensions_source \\ ${LIB_DIR}/libzip.so \\ ${LIB_DIR}/../../lib/libcrypto.so.1.1 \\ ${LIB_DIR}/../../lib/libssl.so.1.1 \\ ${LIB_DIR}/libstdc* \\ ${LIB_DIR}/libicudata.so \\ ${LIB_DIR}/libicui18n.so \\ ${LIB_DIR}/libicuio.so \\ ${LIB_DIR}/libicutest.so \\ ${LIB_DIR}/libicutu.so \\ ${LIB_DIR}/libicuuc.so \\ ${LIB_DIR}/libgcc_s.so.1 \\ ${LIB_DIR}/libpng.so \\ ${LIB_DIR}/libc-client.so \\ ${LIB_DIR}/libbz2.so \\ ${LIB_DIR}/libldap.so \\ ${LIB_DIR}/libldap_r-2.4.so.2 \\ ${LIB_DIR}/libldap_r.so \\ ${LIB_DIR}/liblber.so \\ ${LIB_DIR}/libsasl2.so ${LIB_DIR}/ RUN docker-php-ext-enable zip mbstring intl gd imap xml mysqli json bcmath \\ bz2 pdo pdo_mysql ldap # Refa\u00e7o a c\u00f3pia pois o comando docker-php-ext-enable faz purge de algumas libs COPY --from=extensions_source ${LIB_DIR}/libstdc* ${LIB_DIR}/libgcc_s.so.1 ${LIB_DIR}/ # Instalando o composer RUN php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" && \\ php composer-setup.php && \\ php -r \"unlink('composer-setup.php');\" && \\ mv composer.phar /usr/local/bin/composer && \\ /usr/local/bin/composer global require hirak/prestissimo # Limpando a imagem RUN rm -rf /var/cache/apk/* /tmp/* /usr/share/man /usr/local/lib/php/doc/* Note que primeiramente eu declaro um FROM e o nomeio utilizando o parametro AS e nesse est\u00e1gio s\u00e3o realizadas as instala\u00e7\u00f5es das extens\u00f5es necess\u00e1rias. Conclu\u00eddas as instala\u00e7\u00f5es, \u00e9 realizada a declara\u00e7\u00e3o de um novo FROM que far\u00e1 o build da imagem final. Neste est\u00e1gio utilizando o par\u00e2metro COPY --from=nome_do_est\u00e1gio \u00e9 poss\u00edvel referenciar o est\u00e1gio anterior e copiar apenas os arquivos que nos interessam. Adicionalmente, eu adiciono ao final do arquivo um comando para excluir arquivos de cache, tempor\u00e1rios e documenta\u00e7\u00e3o. Vejamos o resultado: A imagem gerada utilizando o Builder Pattern ficou com 156MB. S\u00e3o 148MB a menos que a imagem Alpine e 368MB de diferen\u00e7a para a imagem Debian. Uma redu\u00e7\u00e3o de 70% no tamanho original da imagem Debian com as extens\u00f5es.","title":"Builder Pattern"},{"location":"php-k8s-gitlab-parte1/#conclusao","text":"Vimos que: 1. Com o simples fato de optarmos pela distro Alpine Linux na hora de construir nossos containers podemos criar imagens muito mais enxutas; 2. Que com um pouquinho de trabalho, usando o Builder Pattern \u00e9 poss\u00edvel otimizar ainda mais estas imagens; 3. Quando estamos falando de imagens de container para o Kubernetes, tamanho \u00e9 sim importante . No pr\u00f3ximo post, entrarei no mundo do Kubernetes propriamente dito criando os arquivos de manifesto para o deploy de uma app PHP no K8s. At\u00e9 l\u00e1!","title":"Conclus\u00e3o"},{"location":"shell/","text":"Dicas de Shell Scripting Vari\u00e1vel RANDOM Umas das coisas que ajuda muito na administra\u00e7\u00e3o de servidores \u00e9 ter um conhecimento razo\u00e1vel de programa\u00e7\u00e3o para a cria\u00e7\u00e3o de scripts. No Linux, o interpretador de comandos bash j\u00e1 fornece as ferramentas necess\u00e1rias para a constru\u00e7\u00e3o de scripts que ajudar\u00e3o o dia-a-dia da administra\u00e7\u00e3o do sistema. Dessa forma pretendo iniciar alguns posts com algumas dicas de scripts, a come\u00e7ar com a vari\u00e1vel de ambiente RANDOM. Com esta vari\u00e1vel \u00e9 possivel gerar um valor inteiro aleat\u00f3rio de 0 at\u00e9 32767. Isto pode ser muito \u00fatil por exemplo para gerar senhas num\u00e9ricas randomicas: user@maquina:~$ for i in `seq 1 8`;do c=`echo $RANDOM|cut -c1`;echo -n $c;done;echo Ou para um prop\u00f3sito menos s\u00e9rio que a administra\u00e7\u00e3o do sistema voc\u00ea pode fazer um script que gere jogos da mega-sena \ud83d\ude00 : #!/bin/bash TOTAL=10; # Qtde de jogos DEZENAS=6; # Dezenas a serem geradas MAX=60; # Maior numero possivel no jogo MIN=1; # Menor numero possivel no jogo for seq_jogos in `seq 1 $TOTAL`; do for seq_dezenas in `seq 1 $DEZENAS`; do while [ \"$valido\" != \"OK\" ]; # Roda at\u00e9 aparecer um n\u00famero v\u00e1lido do dezena=$RANDOM; if [ $dezena -ge $MIN ] && [ $dezena -le $MAX ]; then # Garantindo que o n\u00famero n\u00e3o vai se repetir # S\u00f3 atribui o valor de dezena na vari\u00e1vel jogo se esse valor n\u00e3o estiver contido nela. echo $jogo|grep -w $dezena >/dev/null|| jogo=\"$jogo $dezena\"; valido=\"OK\"; fi done valido=\"\"; done echo \"Jogo $seq_jogos: $jogo\"; jogo=\"\"; done Um abra\u00e7o a todos e at\u00e9 a pr\u00f3xima!","title":"Dicas de Shell Scripting"},{"location":"shell/#dicas-de-shell-scripting","text":"","title":"Dicas de Shell Scripting"},{"location":"shell/#variavel-random","text":"Umas das coisas que ajuda muito na administra\u00e7\u00e3o de servidores \u00e9 ter um conhecimento razo\u00e1vel de programa\u00e7\u00e3o para a cria\u00e7\u00e3o de scripts. No Linux, o interpretador de comandos bash j\u00e1 fornece as ferramentas necess\u00e1rias para a constru\u00e7\u00e3o de scripts que ajudar\u00e3o o dia-a-dia da administra\u00e7\u00e3o do sistema. Dessa forma pretendo iniciar alguns posts com algumas dicas de scripts, a come\u00e7ar com a vari\u00e1vel de ambiente RANDOM. Com esta vari\u00e1vel \u00e9 possivel gerar um valor inteiro aleat\u00f3rio de 0 at\u00e9 32767. Isto pode ser muito \u00fatil por exemplo para gerar senhas num\u00e9ricas randomicas: user@maquina:~$ for i in `seq 1 8`;do c=`echo $RANDOM|cut -c1`;echo -n $c;done;echo Ou para um prop\u00f3sito menos s\u00e9rio que a administra\u00e7\u00e3o do sistema voc\u00ea pode fazer um script que gere jogos da mega-sena \ud83d\ude00 : #!/bin/bash TOTAL=10; # Qtde de jogos DEZENAS=6; # Dezenas a serem geradas MAX=60; # Maior numero possivel no jogo MIN=1; # Menor numero possivel no jogo for seq_jogos in `seq 1 $TOTAL`; do for seq_dezenas in `seq 1 $DEZENAS`; do while [ \"$valido\" != \"OK\" ]; # Roda at\u00e9 aparecer um n\u00famero v\u00e1lido do dezena=$RANDOM; if [ $dezena -ge $MIN ] && [ $dezena -le $MAX ]; then # Garantindo que o n\u00famero n\u00e3o vai se repetir # S\u00f3 atribui o valor de dezena na vari\u00e1vel jogo se esse valor n\u00e3o estiver contido nela. echo $jogo|grep -w $dezena >/dev/null|| jogo=\"$jogo $dezena\"; valido=\"OK\"; fi done valido=\"\"; done echo \"Jogo $seq_jogos: $jogo\"; jogo=\"\"; done Um abra\u00e7o a todos e at\u00e9 a pr\u00f3xima!","title":"Vari\u00e1vel RANDOM"},{"location":"sobre/","text":"Gustavo Ant\u00e3o Natural de Mar\u00edlia, interior de SP, iniciei minha carreira em tecnologia em 1998 em um provedor de Internet (na \u00e9poca ZAZ hoje Terra Networks )atuando como suporte t\u00e9cnico. O interesse pela \u00e1rea foi tamanho que em 8 meses de trabalho eu j\u00e1 me interessava por Linux, Networking e desenvolvimento. Ap\u00f3s sa\u00edr do provedor, trabalhei em uma consultoria que era representante oficial do Conectiva Linux e durante dois anos consecutivos obtive a Certifica\u00e7\u00e3o Avan\u00e7ada Conectiva Linux (RIP, sdds ), pois era necess\u00e1rio para ministrar os treinamentos oficiais. Ap\u00f3s um curto per\u00edodo trabalhando como freelance, fui contratado para cuidar da \u00e1rea de servidores e redes da Unimed de Mar\u00edlia , onde permaneci por quase 15 anos. Diante da necessidade de enfrentar novos desafios na carreira, me despedi da Unimed em 2018 e desde ent\u00e3o fa\u00e7o parte do time de SRE da Tray Ecommerce , lugar onde tenho encontrado os desafios e aprendizados que buscava quando decidi sair da Unimed. Na Tray tenho atuado fortemente na \u00e1rea de conteineriza\u00e7\u00e3o de aplica\u00e7\u00f5es e orquestra\u00e7\u00e3o de containers com Kubernetes, mas n\u00e3o limitado \u00e0 isso, trabalhando com tamb\u00e9m com balanceadores de carga, webservers, servi\u00e7os de fila, caching, scripting e automa\u00e7\u00e3o. Fora do escopo profissional sou uma pessoa bem tranquila, caseiro, pai de duas lindas meninas e apaixonado pela minha esposa. Aqui vou procurar manter registrado coisas que achar interessantes ou que sinta que valham a pena serem compartilhadas. Social Media LinkedIN Github Youtube","title":"Sobre"},{"location":"sobre/#gustavo-antao","text":"Natural de Mar\u00edlia, interior de SP, iniciei minha carreira em tecnologia em 1998 em um provedor de Internet (na \u00e9poca ZAZ hoje Terra Networks )atuando como suporte t\u00e9cnico. O interesse pela \u00e1rea foi tamanho que em 8 meses de trabalho eu j\u00e1 me interessava por Linux, Networking e desenvolvimento. Ap\u00f3s sa\u00edr do provedor, trabalhei em uma consultoria que era representante oficial do Conectiva Linux e durante dois anos consecutivos obtive a Certifica\u00e7\u00e3o Avan\u00e7ada Conectiva Linux (RIP, sdds ), pois era necess\u00e1rio para ministrar os treinamentos oficiais. Ap\u00f3s um curto per\u00edodo trabalhando como freelance, fui contratado para cuidar da \u00e1rea de servidores e redes da Unimed de Mar\u00edlia , onde permaneci por quase 15 anos. Diante da necessidade de enfrentar novos desafios na carreira, me despedi da Unimed em 2018 e desde ent\u00e3o fa\u00e7o parte do time de SRE da Tray Ecommerce , lugar onde tenho encontrado os desafios e aprendizados que buscava quando decidi sair da Unimed. Na Tray tenho atuado fortemente na \u00e1rea de conteineriza\u00e7\u00e3o de aplica\u00e7\u00f5es e orquestra\u00e7\u00e3o de containers com Kubernetes, mas n\u00e3o limitado \u00e0 isso, trabalhando com tamb\u00e9m com balanceadores de carga, webservers, servi\u00e7os de fila, caching, scripting e automa\u00e7\u00e3o. Fora do escopo profissional sou uma pessoa bem tranquila, caseiro, pai de duas lindas meninas e apaixonado pela minha esposa. Aqui vou procurar manter registrado coisas que achar interessantes ou que sinta que valham a pena serem compartilhadas.","title":"Gustavo Ant\u00e3o"},{"location":"sobre/#social-media","text":"","title":"Social Media"},{"location":"sobre/#linkedin","text":"","title":" LinkedIN"},{"location":"sobre/#github","text":"","title":" Github"},{"location":"sobre/#youtube","text":"","title":" Youtube"},{"location":"vim/","text":"Editor VIM Substitui\u00e7\u00e3o de Caracteres/Palavras Algo que ajuda bastante na administra\u00e7\u00e3o de servidores *nix \u00e9 saber usar bem o editor vi . O vi ou vim \u00e9 um dos mais populares editores do mundo unix e pode ser encontrado em quase todos os SO\u2019s unix based. Uma tarefa muito chata e relativamente frequ\u00eante na adm. de servidores \u00e9 a edi\u00e7\u00e3o de arquivos onde temos de substituir v\u00e1rias ocorr\u00eancias de uma string por outra. Mas esse \u00e9 um problema de f\u00e1cil solu\u00e7\u00e3o com os comandos do vi. Vamos a um exemplo, digamos que temos o arquivo teste.txt com o seguinte conte\u00fado: usuario1@dominioerrado.com usuario2@dominioerrado.com usuario3@dominioerrado.com usuario4@dominioerrado.com usuario5@dominioerrado.com Voc\u00ea notou que numa lista de e-mails o dom\u00ednio veio errado e precisa corrigir, mas seu arquivo tem mais de 50000 linhas. Quer fazer manualmente? Com o arquivo aberto no vi digite a sequ\u00eancia de comandos: [ESC] : (Tecla ESC em seguida o dois-pontos ) Isso far\u00e1 com que o editor entre no modo de comandos, a seguir digite: %s/dominioerrado/dominiocorreto/g Pressione ENTER. O resultado ser\u00e1 que todas as ocorr\u00eancias de dominioerrado ser\u00e3o substitu\u00eddas por dominiocorreto, isto porque o sinal % no come\u00e7o indica que o comando ser\u00e1 executado desde a 1\u00aa linha do arquivo, em seguida o s indica que ser\u00e1 um comando de substitui\u00e7\u00e3o, as strings entre / s\u00e3o a string original e a nova string respectivamente e o g no final indica que o comando n\u00e3o parar\u00e1 sua execu\u00e7\u00e3o ao encontrar a 1\u00aa ocorr\u00eancia, fazendo com que a substitui\u00e7\u00e3o ocorra do inicio ao fim do arquivo. Uma outra utiliza\u00e7\u00e3o frequente deste mesmo comando \u00e9 quando abrimos no vi um arquivo criado em um ambiente Windows e em cada quebra de linha existe um ^M . Por\u00e9m neste caso em espec\u00edfico h\u00e1 uma diferen\u00e7a pois embora apresentado com 2 simbolos o ^M \u00e9 identificado pelo vi como apenas 1 caracter, ou seja se vc tentar fazer a substitui\u00e7\u00e3o digitando no campo da string original o caracter ^ seguido de M o comando n\u00e3o funcionar\u00e1. Para remover estes caracteres especiais voc\u00ea deve digitar: [ESC]: %s/[CTRL]v[CTRL]m//g Para que o caracter ^M seja compreendido pelo editor voc\u00ea dever\u00e1 digitar a sequ\u00eancia [CTRL]+v+[CTRL]+M e mantendo o segundo campo string vazio todas as ocorr\u00eancias do caracter ser\u00e3o removidas. Obviamente existem outras maneiras de se conseguir o mesmo resultado via linha de comando (sed... coff... coff...) mas essa fica pra uma pr\u00f3xima. Abra\u00e7os!","title":"Dicas VIM"},{"location":"vim/#editor-vim","text":"","title":"Editor VIM"},{"location":"vim/#substituicao-de-caracterespalavras","text":"Algo que ajuda bastante na administra\u00e7\u00e3o de servidores *nix \u00e9 saber usar bem o editor vi . O vi ou vim \u00e9 um dos mais populares editores do mundo unix e pode ser encontrado em quase todos os SO\u2019s unix based. Uma tarefa muito chata e relativamente frequ\u00eante na adm. de servidores \u00e9 a edi\u00e7\u00e3o de arquivos onde temos de substituir v\u00e1rias ocorr\u00eancias de uma string por outra. Mas esse \u00e9 um problema de f\u00e1cil solu\u00e7\u00e3o com os comandos do vi. Vamos a um exemplo, digamos que temos o arquivo teste.txt com o seguinte conte\u00fado: usuario1@dominioerrado.com usuario2@dominioerrado.com usuario3@dominioerrado.com usuario4@dominioerrado.com usuario5@dominioerrado.com Voc\u00ea notou que numa lista de e-mails o dom\u00ednio veio errado e precisa corrigir, mas seu arquivo tem mais de 50000 linhas. Quer fazer manualmente? Com o arquivo aberto no vi digite a sequ\u00eancia de comandos: [ESC] : (Tecla ESC em seguida o dois-pontos ) Isso far\u00e1 com que o editor entre no modo de comandos, a seguir digite: %s/dominioerrado/dominiocorreto/g Pressione ENTER. O resultado ser\u00e1 que todas as ocorr\u00eancias de dominioerrado ser\u00e3o substitu\u00eddas por dominiocorreto, isto porque o sinal % no come\u00e7o indica que o comando ser\u00e1 executado desde a 1\u00aa linha do arquivo, em seguida o s indica que ser\u00e1 um comando de substitui\u00e7\u00e3o, as strings entre / s\u00e3o a string original e a nova string respectivamente e o g no final indica que o comando n\u00e3o parar\u00e1 sua execu\u00e7\u00e3o ao encontrar a 1\u00aa ocorr\u00eancia, fazendo com que a substitui\u00e7\u00e3o ocorra do inicio ao fim do arquivo. Uma outra utiliza\u00e7\u00e3o frequente deste mesmo comando \u00e9 quando abrimos no vi um arquivo criado em um ambiente Windows e em cada quebra de linha existe um ^M . Por\u00e9m neste caso em espec\u00edfico h\u00e1 uma diferen\u00e7a pois embora apresentado com 2 simbolos o ^M \u00e9 identificado pelo vi como apenas 1 caracter, ou seja se vc tentar fazer a substitui\u00e7\u00e3o digitando no campo da string original o caracter ^ seguido de M o comando n\u00e3o funcionar\u00e1. Para remover estes caracteres especiais voc\u00ea deve digitar: [ESC]: %s/[CTRL]v[CTRL]m//g Para que o caracter ^M seja compreendido pelo editor voc\u00ea dever\u00e1 digitar a sequ\u00eancia [CTRL]+v+[CTRL]+M e mantendo o segundo campo string vazio todas as ocorr\u00eancias do caracter ser\u00e3o removidas. Obviamente existem outras maneiras de se conseguir o mesmo resultado via linha de comando (sed... coff... coff...) mas essa fica pra uma pr\u00f3xima. Abra\u00e7os!","title":"Substitui\u00e7\u00e3o de Caracteres/Palavras"}]}